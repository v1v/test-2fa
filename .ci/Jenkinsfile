#!/usr/bin/env groovy

@Library('apm@current') _

pipeline {
  agent { label 'ubuntu-18 && immutable' }
  environment {
    REPO = 'test-2fa'
    BASE_DIR = "src/github.com/elastic/${env.REPO}"
    PIPELINE_LOG_LEVEL = 'INFO'
    DOCKERELASTIC_SECRET = 'secret/observability-team/ci/docker-registry/prod'
    DOCKER_REGISTRY = 'docker.elastic.co'
    NODE_DOCKER_IMAGE = "${env.DOCKER_REGISTRY}/observability-ci/node-cypress:latest"
    SECCOMP_FILE = "${env.WORKSPACE}/${env.BASE_DIR}/.ci/seccomp_profile.json"
    DOCKER_IMG = "${env.DOCKER_REGISTRY}/observability-ci/synthetics"
    DOCKER_IMG_PUBLIC = "${env.DOCKER_REGISTRY}/experimental/synthetics"
    NPMRC_SECRET = 'secret/apm-team/ci/elastic-observability-npmjs'
    TOTP_SECRET = 'totp-apm/code/v1v'
  }
  options {
    timeout(time: 12, unit: 'HOURS')  // to support releases then we will add a timeout in each stage
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
    quietPeriod(10)
  }
  parameters {
    booleanParam(name: 'release', defaultValue: false, description: 'Release. If so, all the other parameters will be ignored when releasing from master.')
  }
  stages {
    /**
     Checkout the code and stash it, to use it on other stages.
     */
    stage('Checkout') {
      options {
        timeout(5)
      }
      steps {
        deleteDir()
        gitCheckout(basedir: "${BASE_DIR}")
        retryWithSleep(retries: 3, seconds: 5, backoff: true) {
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'Download dependencies',script: 'npm install')
            }
          }
        }
        //stash allowEmpty: true, name: 'source', useDefaultExcludes: false, excludes: ".npm/_cacache/**,.nvm/.git/**"
      }
    }
    stage('Build') {
      options {
        timeout(5)
      }
      steps {
        withGithubNotify(context: 'Build') {
          //cleanup()
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'Build',script: 'npm run build')
            }
          }
        }
      }
    }
    stage('Release') {
      options {
        skipDefaultCheckout()
      }
      stages {
        stage('Notify') {
          options { skipDefaultCheckout() }
          steps {
            notifyStatus(slackStatus: 'warning', subject: "[${env.REPO}] Release ready to be pushed",
                         body: "Please go to (<${env.BUILD_URL}input|here>) to approve or reject within 12 hours.")
          }
        }
        stage('Release CI') {
          options { skipDefaultCheckout() }
          input {
            message 'Should we release a new version?'
            ok 'Yes, we should.'
          }
          steps {
            //cleanup()
            withNodeEnv(){
              dir("${BASE_DIR}"){
                prepareRelease() {
                  sh(script: "npm publish --otp=${env.TOTP_CODE} --tag alpha", label: 'publish to NPM')
                  setEnvVar('VERSION', sh(script: '''node -p "require('./package.json').version"''', returnStdout: true).trim())
                  sh(script: "npm dist-tag add @elastic/test-2fa@${env.VERSION} latest", label: 'retag latest')
                }
              }
            }
          }
          post {
            success {
              notifyStatus(slackStatus: 'good', subject: "[${env.REPO}] Release '${VERSION}' published", body: "Great news, the release has been done successfully. (<${env.RUN_DISPLAY_URL}|Open>). \n Release URL: (<https://github.com/elastic/apm-agent-rum-js/releases|Here>)")
            }
            always {
              script {
                currentBuild.description = "${currentBuild.description?.trim() ? currentBuild.description : ''} released"
              }
            }
          }
        }
      }
      post {
        failure {
          notifyStatus(slackStatus: 'danger', subject: "[${env.REPO}] Release failed", body: "(<${env.RUN_DISPLAY_URL}|Open>)")
        }
      }
    }
  }
}

def cleanup(){
  dir("${BASE_DIR}"){
    deleteDir()
  }
  unstash 'source'
}

def withNodeEnv(Map args=[:], Closure body){
  withEnv(["HOME=${WORKSPACE}"]) {
    body()
  }
}

/**
  This is the wrapper to prepare the release context, for such, it's required
  to decouple the build environment preparation from the TOTP access, otherwise
  the TOTP might expire if it takes too long.
 */
def prepareRelease(Closure body){
  withNpmrc(secret: "${env.NPMRC_SECRET}", path: "${env.WORKSPACE}/${env.BASE_DIR}") {
    withGitRelease(credentialsId: '2a9602aa-ab9f-4e52-baf3-b71ca88469c7-UserAndToken') {
      sh(script: 'npm ci', label: 'prepare the ci environment')
      sh(script: 'npm version prerelease --preid=alpha', label: 'bump the alpha version')
      gitPush()
      gitPush(args: '--tags')
      withTotpVault(secret: "${env.TOTP_SECRET}", code_var_name: 'TOTP_CODE'){
        body()
      }
    }
  }
}

/**
  This is the wrapper to send notifications for the release process through
  slack and email, since it requires some formatting to support the same
  message in both systems.
 */
def notifyStatus(def args = [:]) {
  slackSend(channel: '#oblt-robots', color: args.slackStatus, message: "${args.subject}. ${args.body}",
            tokenCredentialId: 'jenkins-slack-integration-token')
  // transform slack URL format '(<URL|description>)' to 'URL'.
  def bodyEmail = args.body.replaceAll('\\(<', '').replaceAll('\\|.*>\\)', '')
  // emailext(subject: args.subject, to: 'victor.martinez@elastic.co', body: bodyEmail)
}
